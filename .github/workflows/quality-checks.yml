name: Quality Checks

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

env:
  DOTNET_VERSION: '9.0.x'
  SOLUTION_FILE: 'Payments.Recurring.sln'
  HUSKY: 0

jobs:
  quality-checks:
    name: Code Quality
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/*.props', '**/*.sln') }}
        restore-keys: |
          ${{ runner.os }}-nuget-

    - name: Restore dependencies
      run: dotnet restore ${{ env.SOLUTION_FILE }}

    - name: Verify code format
      run: dotnet format --verify-no-changes ${{ env.SOLUTION_FILE }}

    - name: Build solution
      run: dotnet build ${{ env.SOLUTION_FILE }} --no-restore --configuration Release

    - name: Run tests with coverage
      run: |
        echo "ğŸ§ª Running unit tests with coverage..."
        # Run unit tests without architecture tests (NetArchTest conflicts with coverage collector)
        dotnet test tests/Payments.Core.Tests/Payments.Core.Tests.csproj \
          --no-build \
          --configuration Release \
          --filter "Category!=Architecture" \
          --logger "trx;LogFileName=core_test_results.trx" \
          --collect:"XPlat Code Coverage"

        echo "ğŸ—ï¸ Running architecture tests..."
        # Run architecture tests separately (without coverage due to NetArchTest compatibility)
        dotnet test tests/Payments.Core.Tests/Payments.Core.Tests.csproj \
          --no-build \
          --configuration Release \
          --filter "Category=Architecture" \
          --logger "trx;LogFileName=architecture_test_results.trx"

        echo "ğŸ”Œ Running integration tests with coverage..."
        # Run integration tests with coverage
        dotnet test tests/Payments.Api.IntegrationTests/Payments.Api.IntegrationTests.csproj \
          --no-build \
          --configuration Release \
          --logger "trx;LogFileName=integration_test_results.trx" \
          --collect:"XPlat Code Coverage"

    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: |
          **/*.trx
          **/coverage.cobertura.xml

    - name: Generate coverage report
      run: |
        dotnet tool install --global dotnet-reportgenerator-globaltool
        reportgenerator \
          -reports:"**/coverage.cobertura.xml" \
          -targetdir:"coverage" \
          -reporttypes:"Html;Badges;Cobertura;JsonSummary"

    - name: Upload coverage report
      uses: actions/upload-artifact@v4
      with:
        name: coverage-report
        path: coverage/

    - name: Run security analysis
      run: |
        echo "Running security analysis with built-in analyzers..."

    - name: Run mutation testing
      run: |
        echo "Running mutation testing..."
        if [ ! -d "tests/Payments.Core.Tests" ]; then
          echo "âŒ Core.Tests not found"
          exit 1
        fi

        dotnet tool restore

        # Run Stryker and fail the pipeline if it doesn't execute properly
        if ! dotnet stryker \
          --test-project "tests/Payments.Core.Tests/Payments.Core.Tests.csproj" \
          --project "src/Payments.Core/Payments.Core.csproj" \
          --mutate "**/Domain/**/*.cs" \
          --reporter "html" \
          --reporter "json" \
          --reporter "cleartext" \
          --break-at 0 \
          --threshold-low 40 \
          --threshold-high 60 \
          --verbosity info; then
          echo "âŒ Stryker failed to execute properly"
          exit 1
        fi

        # Check if mutation report was generated
        if ! find StrykerOutput -name "mutation-report.html" -type f | head -1 | xargs test -f; then
          echo "âŒ No mutation report was generated"
          exit 1
        fi

        # Show mutation score if available
        REPORT_PATH=$(find StrykerOutput -name "mutation-report.html" -type f | head -1)
        if [ -n "$REPORT_PATH" ]; then
          echo "ğŸ“Š Mutation report generated at: $REPORT_PATH"
        fi

        echo "âœ… Mutation testing completed successfully"

    - name: Upload mutation report
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: mutation-report
        path: |
          StrykerOutput/**/reports/
          StrykerOutput/**/*.html

    - name: Generate quality summary
      run: |
        SUMMARY_FILE="quality-summary.md"
        STEP_SUMMARY_OUTPUT="${GITHUB_STEP_SUMMARY:-}"

        export LC_ALL=C

        append_line() {
          printf '%s\n' "$1" >> "$SUMMARY_FILE"
          if [ -n "$STEP_SUMMARY_OUTPUT" ]; then
            printf '%s\n' "$1" >> "$STEP_SUMMARY_OUTPUT"
          fi
        }

        append_blank() {
          append_line ""
        }

        append_format() {
          local format=$1
          shift || true
          local rendered
          rendered=$(printf "$format" "$@")
          append_line "$rendered"
        }

        : > "$SUMMARY_FILE"

        append_line "# ğŸ“Š Quality Report Summary"
        append_blank

        if [ -f "coverage/Summary.json" ]; then
          COVERAGE=$(jq -r '.summary.linecoverage // .summary.lineCoverage // empty' coverage/Summary.json || true)
          if [ -n "$COVERAGE" ]; then
            append_line "## ğŸ“ˆ Code Coverage"
            append_format "**Total:** %.1f%%" "$COVERAGE"

            ASSEMBLY_ROWS=$(jq -r '.coverage.assemblies[]? | select(.coverage != null) | "\(.name)|\(.coverage)"' coverage/Summary.json || true)
            if [ -n "$ASSEMBLY_ROWS" ]; then
              append_blank
              append_line "| Project | Coverage |"
              append_line "| --- | --- |"
              while IFS='|' read -r NAME VALUE; do
                [ -z "$NAME" ] && continue
                append_format "| %s | %.1f%% |" "$NAME" "$VALUE"
              done <<< "$ASSEMBLY_ROWS"
            fi

            append_blank
          fi
        fi

        append_line "## ğŸ§ª Test Results"
        append_line "**Total Tests:** $(find tests -name "*Test*.cs" -not -path "*bin*" -not -path "*obj*" | wc -l)"
        append_line "**Status:** âœ… All Passed"
        append_blank

        append_line "## ğŸ§¬ Mutation Testing"
        MUTATION_JSON=$(find StrykerOutput -name "mutation-report.json" -path "*/reports/*" -type f | sort | tail -n 1 || true)
        if [ -n "$MUTATION_JSON" ] && [ -f "$MUTATION_JSON" ]; then
          MUTATION_COUNTS=$(jq -r '
            reduce (.files[]?.mutants[]? | .status // empty) as $status (
              {total:0, killed:0, survived:0, noCoverage:0};
              if $status == "Killed" then .total += 1 | .killed += 1
              elif $status == "Survived" then .total += 1 | .survived += 1
              elif $status == "NoCoverage" then .total += 1 | .noCoverage += 1
              else .
              end
            ) | [.total, .killed, .survived, .noCoverage] | @tsv
          ' "$MUTATION_JSON" || true)

          append_line "**Report:** âœ… Generated"

          if [ -n "$MUTATION_COUNTS" ]; then
            IFS=$'\t' read -r TOTAL KILLED SURVIVED NO_COVERAGE <<< "$MUTATION_COUNTS"
            if [ "${TOTAL:-0}" != "0" ] || [ "${KILLED:-0}" != "0" ] || [ "${SURVIVED:-0}" != "0" ] || [ "${NO_COVERAGE:-0}" != "0" ]; then
              append_blank
              append_line "| Metric | Count |"
              append_line "| --- | --- |"
              [ -n "${TOTAL:-}" ] && append_line "| Total mutants | ${TOTAL:-0} |"
              [ -n "${KILLED:-}" ] && append_line "| Killed | ${KILLED:-0} |"
              [ -n "${SURVIVED:-}" ] && append_line "| Survived | ${SURVIVED:-0} |"
              [ -n "${NO_COVERAGE:-}" ] && append_line "| No coverage | ${NO_COVERAGE:-0} |"
            fi
          fi
        else
          append_line "**Report:** âŒ Not found"
        fi
        append_blank

        append_line "## ğŸ›¡ï¸ Security"
        append_line "**Status:** âš ï¸ Not evaluated (placeholder step)"

    - name: Upload quality summary
      uses: actions/upload-artifact@v4
      with:
        name: quality-summary
        path: quality-summary.md

    - name: Comment on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const path = require('path');

          // Read quality summary
          let summary = "## ğŸ“Š Quality Check Results\n\n";

          if (fs.existsSync('coverage/Summary.json')) {
            const coverageData = JSON.parse(fs.readFileSync('coverage/Summary.json', 'utf8'));
            const lineCoverage = coverageData?.summary?.linecoverage ?? coverageData?.summary?.lineCoverage;
            if (typeof lineCoverage === 'number') {
              summary += `ğŸ“ˆ **Coverage:** ${lineCoverage.toFixed(1)}%\n`;
            }

            const assemblies = coverageData?.coverage?.assemblies ?? [];
            if (assemblies.length) {
              summary += `\n| Project | Coverage |\n| --- | --- |\n`;
              for (const assembly of assemblies) {
                if (typeof assembly?.coverage === 'number' && assembly?.name) {
                  summary += `| ${assembly.name} | ${assembly.coverage.toFixed(1)}% |\n`;
                }
              }
              summary += `\n`;
            } else if (typeof lineCoverage === 'number') {
              summary += `\n`;
            }
          }

          summary += `âœ… **Tests:** All passed\n`;

          const resolveLatestMutationReport = () => {
            if (!fs.existsSync('StrykerOutput')) {
              return undefined;
            }

            const candidates = [];
            const queue = ['StrykerOutput'];
            while (queue.length) {
              const current = queue.pop();
              const entries = fs.readdirSync(current, { withFileTypes: true });
              for (const entry of entries) {
                const entryPath = path.join(current, entry.name);
                if (entry.isDirectory()) {
                  queue.push(entryPath);
                } else if (entry.isFile() && entry.name === 'mutation-report.json') {
                  candidates.push(entryPath);
                }
              }
            }

            if (!candidates.length) {
              return undefined;
            }

            candidates.sort();
            return candidates[candidates.length - 1];
          };

          const mutationReportPath = resolveLatestMutationReport();
          if (mutationReportPath) {
            try {
              const mutationData = JSON.parse(fs.readFileSync(mutationReportPath, 'utf8'));
              const files = mutationData?.files ?? {};
              let killed = 0;
              let survived = 0;
              let noCoverage = 0;
              let total = 0;

              for (const file of Object.values(files)) {
                for (const mutant of file?.mutants ?? []) {
                  switch (mutant?.status) {
                    case 'Killed':
                      killed += 1;
                      total += 1;
                      break;
                    case 'Survived':
                      survived += 1;
                      total += 1;
                      break;
                    case 'NoCoverage':
                      noCoverage += 1;
                      total += 1;
                      break;
                  }
                }
              }

              if (total > 0 || killed > 0 || survived > 0 || noCoverage > 0) {
                summary += `ğŸ§¬ **Mutation:** Killed ${killed}, Survived ${survived}, No coverage ${noCoverage} (Total ${total})\n`;
              } else {
                summary += `ğŸ§¬ **Mutation:** âœ… Analysis completed\n`;
              }
            } catch (error) {
              summary += `ğŸ§¬ **Mutation:** âŒ Unable to read report\n`;
            }
          } else {
            summary += `ğŸ§¬ **Mutation:** âŒ Report unavailable\n`;
          }

          summary += `ğŸ›¡ï¸ **Security:** âš ï¸ Not evaluated (placeholder)\n\n`;

          summary += `ğŸ“Š [View detailed reports](${context.payload.repository.html_url}/actions/runs/${context.runId})`;

          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: summary
          });
